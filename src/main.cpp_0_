#include <iostream>
#include <vector>
#include <cmath>
#include <tuple>
#include <array>
#include <initializer_list>

//template <class... Ts>
//void network<Ts...>::propagate_one_layer<network<Ts...>::layer_number>() { return; }

class layer {
    std::vector<double> neurons;

public:
    layer(std::size_t N) : neurons(N) { }

    void set(const std::vector<double> &n) { neurons = n; }
    std::vector<double> get() const { return neurons; }
};

class connection {
public:
    virtual std::vector<double> propagate(const std::vector<double> &x) const = 0;
    virtual std::vector<double> backpropagate(const std::vector<double> &x) const = 0;
};

class fully_connection {
    std::vector<std::vector<double>> w;
    std::vector<double> b;
    std::size_t n, m;

    std::vector<double> dx;

public:
    fully_connection(std::size_t N, std::size_t M) : n(N), m(M), w(N, std::vector<double>(M, 0.0)), b(M, 0.0) { }
    std::vector<double> propagate(const std::vector<double> &x) const {
        std::vector<double> y(m);
        for (int i = 0; i < m; i++) {
            y[i] = 0.0;
            for (int j = 0; j < n; j++) y[i] += w[j][i] * x[j];
        }
        return y;
    }
    std::vector<double> backpropagate(double eta, const std::vector<double> &x, const std::vector<std::vector<double>> &dw) const {
        std::vector<std::vector<double>> nw(N, std::vector<double>(M, 0.0));
        std::vector<double> nb(M, 0.0);

        dx = std::vector<double>();

        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                nw[j][i] += 
            }
        }
    }
};

class network {
    std::vector<layer> layers;
    std::vector<std::function<std::vector<double>()

public:
};

using namespace std;

int main() {
    network<layer<double, 2>, fully_connection<tensor<double, 2>, tensor<double, 2>>
        , layer<double, 2>, fully_connection<tensor<double, 2>, tensor<double, 1>>, layer<double, 1>> n;

    tensor<double, 2> x = {0.0, 0.0};

    tensor<double, 1> o;
    n.propagate(x);

    cout << "out : " << o(0) << endl;

    return 0;
}

